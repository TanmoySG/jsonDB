// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package txlModel

import "fmt"
import "encoding/json"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TxlogSchemaJsonStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TxlogSchemaJsonStatus, v)
	}
	*j = TxlogSchemaJsonStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonEntityPath) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["database"]; !ok || v == nil {
		return fmt.Errorf("field database: required")
	}
	type Plain TxlogSchemaJsonEntityPath
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TxlogSchemaJsonEntityPath(plain)
	return nil
}

type TxlogSchemaJson struct {
	// action performed on entity, pick from permissions
	Action string `json:"action"`

	// actor of transaction
	Actor *string `json:"actor,omitempty"`

	// action performed on entity, pick from permissions
	EntityPath TxlogSchemaJsonEntityPath `json:"entity_path"`

	// type of entity
	EntityType TxlogSchemaJsonEntityType `json:"entity_type"`

	// status of transaction
	Status TxlogSchemaJsonStatus `json:"status"`

	// timestamp of transaction
	Timestamp float64 `json:"timestamp"`

	// HTTP details of transaction
	TransactionDetails TxlogSchemaJsonTransactionDetails `json:"transaction_details"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonTransactionDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["method"]; !ok || v == nil {
		return fmt.Errorf("field method: required")
	}
	if v, ok := raw["request"]; !ok || v == nil {
		return fmt.Errorf("field request: required")
	}
	if v, ok := raw["response"]; !ok || v == nil {
		return fmt.Errorf("field response: required")
	}
	if v, ok := raw["url_endpoint"]; !ok || v == nil {
		return fmt.Errorf("field url_endpoint: required")
	}
	type Plain TxlogSchemaJsonTransactionDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TxlogSchemaJsonTransactionDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonEntityType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TxlogSchemaJsonEntityType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TxlogSchemaJsonEntityType, v)
	}
	*j = TxlogSchemaJsonEntityType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonTransactionDetailsResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["http_status"]; !ok || v == nil {
		return fmt.Errorf("field http_status: required")
	}
	if v, ok := raw["response_body"]; !ok || v == nil {
		return fmt.Errorf("field response_body: required")
	}
	type Plain TxlogSchemaJsonTransactionDetailsResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TxlogSchemaJsonTransactionDetailsResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonTransactionDetailsRequest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["is_authenticated"]; !ok || v == nil {
		return fmt.Errorf("field is_authenticated: required")
	}
	type Plain TxlogSchemaJsonTransactionDetailsRequest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TxlogSchemaJsonTransactionDetailsRequest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJsonTransactionDetailsMethod) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TxlogSchemaJsonTransactionDetailsMethod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TxlogSchemaJsonTransactionDetailsMethod, v)
	}
	*j = TxlogSchemaJsonTransactionDetailsMethod(v)
	return nil
}

// action performed on entity, pick from permissions
type TxlogSchemaJsonEntityPath struct {
	// collection name, must also have database
	Collection *string `json:"collection,omitempty"`

	// database name
	Database string `json:"database"`
}

type TxlogSchemaJsonEntityType string

const TxlogSchemaJsonEntityTypeCOLLECTION TxlogSchemaJsonEntityType = "COLLECTION"
const TxlogSchemaJsonEntityTypeDATABASE TxlogSchemaJsonEntityType = "DATABASE"

type TxlogSchemaJsonStatus string

const TxlogSchemaJsonStatusFAILED TxlogSchemaJsonStatus = "FAILED"
const TxlogSchemaJsonStatusSUCCESS TxlogSchemaJsonStatus = "SUCCESS"

// HTTP details of transaction
type TxlogSchemaJsonTransactionDetails struct {
	// HTTP method of transaction
	Method TxlogSchemaJsonTransactionDetailsMethod `json:"method"`

	// request details of transaction
	Request TxlogSchemaJsonTransactionDetailsRequest `json:"request"`

	// response details of transaction
	Response TxlogSchemaJsonTransactionDetailsResponse `json:"response"`

	// transaction endpoint/url
	UrlEndpoint string `json:"url_endpoint"`
}

type TxlogSchemaJsonTransactionDetailsMethod string

const TxlogSchemaJsonTransactionDetailsMethodDELETE TxlogSchemaJsonTransactionDetailsMethod = "DELETE"
const TxlogSchemaJsonTransactionDetailsMethodGET TxlogSchemaJsonTransactionDetailsMethod = "GET"
const TxlogSchemaJsonTransactionDetailsMethodPATCH TxlogSchemaJsonTransactionDetailsMethod = "PATCH"
const TxlogSchemaJsonTransactionDetailsMethodPOST TxlogSchemaJsonTransactionDetailsMethod = "POST"

// request details of transaction
type TxlogSchemaJsonTransactionDetailsRequest struct {
	// check if actor is authenticated
	IsAuthenticated bool `json:"is_authenticated"`

	// payload of HTTP transaction
	Payload *string `json:"payload,omitempty"`

	// user-agent of http transaction
	UserAgent TxlogSchemaJsonTransactionDetailsRequestUserAgent `json:"user-agent,omitempty"`
}

// user-agent of http transaction
type TxlogSchemaJsonTransactionDetailsRequestUserAgent map[string]interface{}

// response details of transaction
type TxlogSchemaJsonTransactionDetailsResponse struct {
	// response HTTP status of transaction
	HttpStatus int `json:"http_status"`

	// response payload/body of transaction
	ResponseBody string `json:"response_body"`
}

var enumValues_TxlogSchemaJsonEntityType = []interface{}{
	"DATABASE",
	"COLLECTION",
}
var enumValues_TxlogSchemaJsonStatus = []interface{}{
	"SUCCESS",
	"FAILED",
}
var enumValues_TxlogSchemaJsonTransactionDetailsMethod = []interface{}{
	"POST",
	"GET",
	"DELETE",
	"PATCH",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TxlogSchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["action"]; !ok || v == nil {
		return fmt.Errorf("field action: required")
	}
	if v, ok := raw["entity_path"]; !ok || v == nil {
		return fmt.Errorf("field entity_path: required")
	}
	if v, ok := raw["entity_type"]; !ok || v == nil {
		return fmt.Errorf("field entity_type: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp: required")
	}
	if v, ok := raw["transaction_details"]; !ok || v == nil {
		return fmt.Errorf("field transaction_details: required")
	}
	type Plain TxlogSchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TxlogSchemaJson(plain)
	return nil
}
